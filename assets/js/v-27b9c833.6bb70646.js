"use strict";(self.webpackChunknotebook=self.webpackChunknotebook||[]).push([[4329],{7080:(e,a,r)=>{r.r(a),r.d(a,{data:()=>t});const t={key:"v-27b9c833",path:"/kernel/trace/aarch64_debug.html",title:"AArch64 Debug",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"ARM debug hardware",slug:"arm-debug-hardware",children:[{level:3,title:"Software/Hardware breakpoint",slug:"software-hardware-breakpoint",children:[]},{level:3,title:"Halt or Self-hosted debug",slug:"halt-or-self-hosted-debug",children:[]}]},{level:2,title:"ARM trace hardware",slug:"arm-trace-hardware",children:[{level:3,title:"Embedded Trace Macrocell (ETM)",slug:"embedded-trace-macrocell-etm",children:[]}]}],filePathRelative:"kernel/trace/aarch64_debug.md",git:{updatedTime:162541353e4,contributors:[{name:"Zhang Junyu",email:"zhangjunyu.92@bytedance.com",commits:1}]}}},4929:(e,a,r)=>{r.r(a),r.d(a,{default:()=>n});const t=(0,r(6252).uE)('<h1 id="aarch64-debug" tabindex="-1"><a class="header-anchor" href="#aarch64-debug" aria-hidden="true">#</a> AArch64 Debug</h1><h2 id="arm-debug-hardware" tabindex="-1"><a class="header-anchor" href="#arm-debug-hardware" aria-hidden="true">#</a> ARM debug hardware</h2><p><strong>Invasive debug</strong> provides facilities that enable you to stop programs and step through them line by line.</p><h3 id="software-hardware-breakpoint" tabindex="-1"><a class="header-anchor" href="#software-hardware-breakpoint" aria-hidden="true">#</a> Software/Hardware breakpoint</h3><ul><li>Software breakpoint</li></ul><p>The HLT instruction causes the core to enter debug state if an external debugger is connected and relevant security permissions permit entry to debug state.</p><p>The BRK instruction in AArch64 generates a synchronous debug exception but does not cause the core to enter debug state.</p><p><strong>Software can only be used on code that is stored in RAM.</strong></p><ul><li>Hardware breakpoint</li></ul><p>Hardware breakpoints use comparators built into the core and stop execution when execution reaches the specified address. These can be <strong>used anywhere in memory</strong>, as they do not require changes to code, but the hardware provides limited numbers of hardware breakpoint units.</p><p>The Cortex-A57 processor, for example, has six hardware breakpoints and four watchpoints available in hardware resources. See the Debug ID Register (DBGDIDR) to obtain these values for a given implementation.</p><h3 id="halt-or-self-hosted-debug" tabindex="-1"><a class="header-anchor" href="#halt-or-self-hosted-debug" aria-hidden="true">#</a> Halt or Self-hosted debug</h3><p><strong>In halting debug, the debug event causes the core to enter debug state.</strong></p><p>In debug state, the core is halted, meaning that it no longer fetches instructions. Instead, the core executes instructions under the direction of a debugger running on a different host connected through JTAG, or another external interface.</p><p>The basic principles of halting debug is:</p><ul><li>When programmed for halting debug, a debug event causes entry to a special Debug state.</li><li>In Debug state, the core does not fetch instructions from memory, but from a special Instruction Transfer Register.</li><li>Data Transfer Registers are used to move register and memory content between host and target.</li></ul><p><strong>In monitor debug, the debug event causes a debug exception to be raised.</strong> The exception must be handled by dedicated debug monitor software running on the same core. Monitor debug presupposes software support.</p><h2 id="arm-trace-hardware" tabindex="-1"><a class="header-anchor" href="#arm-trace-hardware" aria-hidden="true">#</a> ARM trace hardware</h2><p><strong>Non-invasive debug</strong> enables observation of the core behavior while it is executing.</p><p>It is possible to record memory accesses performed (including address and data values) and generate a real-time trace of the program, seeing peripheral accesses, stack and heap accesses and changes to variables.</p><h3 id="embedded-trace-macrocell-etm" tabindex="-1"><a class="header-anchor" href="#embedded-trace-macrocell-etm" aria-hidden="true">#</a> Embedded Trace Macrocell (ETM)</h3><p>In some cases, there is one ETM per core. System-on-Chip designers can omit this block from their silicon to reduce costs. These blocks observe, but do not affect, core behavior and are able to monitor instruction execution and data accesses.</p>',22),n={render:function(e,a){return t}}}}]);