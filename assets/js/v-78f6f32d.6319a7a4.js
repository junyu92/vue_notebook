"use strict";(self.webpackChunknotebook=self.webpackChunknotebook||[]).push([[8289],{6212:(e,t,a)=>{a.r(t),a.d(t,{data:()=>o});const o={key:"v-78f6f32d",path:"/kernel/memory/memory_tagging_extension.html",title:"Memory Tagging Extension",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Example",slug:"example",children:[]}],filePathRelative:"kernel/memory/memory_tagging_extension.md",git:{updatedTime:1626934689e3,contributors:[{name:"Zhang Junyu",email:"zhangjunyu.92@bytedance.com",commits:1}]}}},5685:(e,t,a)=>{a.r(t),a.d(t,{default:()=>n});const o=(0,a(6252).uE)('<h1 id="memory-tagging-extension" tabindex="-1"><a class="header-anchor" href="#memory-tagging-extension" aria-hidden="true">#</a> Memory Tagging Extension</h1><p>The extension introduces a notion of two types of tags:</p><ul><li>address tags</li><li>memory tags</li></ul><p>Every time a heap region is allocated, the software chooses a random 4-bit tag and marks both the address and all the newly allocated memory granules with this tag.</p><p>The load and store instructions verify that the address tag matches the memory tag, causing a hardware exception on tag mismatch.</p><h2 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h2><p>When the user code requests 20 bytes of heap to be allocated, operator new() rounds up the size to the 16-byte boundary (i.e., to 32), allocates a 32-byte chunk of memory (i.e., two 16-byte memory granules), chooses a random 4-bit tag (in this case, 0xA), puts this tag into the top-byte of the address, and updates the tags for the two newly allocated memory granules.</p><p>The adjacent memory regions have different memory tags, so when the code tries to access memory at offset 32 from the pointer, MTE raises an exception because the tag of the pointer does not match the tag of the memory granule being accessed.</p>',8),n={render:function(e,t){return o}}}}]);